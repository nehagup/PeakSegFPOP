PeakSegFPOP

Command line limited memory PeakSeg functional pruning optimal
partitioning algorithm.

[[https://travis-ci.org/tdhock/PeakSegFPOP][https://travis-ci.org/tdhock/PeakSegFPOP.png?branch=master]]

** Installation

#+BEGIN_SRC shell-script
sudo aptitude install libdb6.0++-dev libdb6.0-stl-dev
make
cp PeakSegFPOP ~/bin # or wherever is on your $PATH
#+END_SRC

BerkeleyDB is used by PeakSegFPOP to write a large temporary file to
disk. If you don't have root or aptitude, then you can always install
BerkeleyDB by hand to your home directory

#+BEGIN_SRC shell-script
wget http://download.oracle.com/berkeley-db/db-6.2.23.NC.tar.gz
tar xf db-6.2.23.NC.tar.gz
cd db-6.2.23.NC/build_unix
../dist/configure --prefix=$HOME --enable-stl
make
make install
#+END_SRC 

If BerkeleyDB is installed to your home directory or some other
non-standard directory, then make sure to edit the [[file:Makefile]] to
tell the compiler where to find it.

#+BEGIN_SRC 
g++ -std=c++0x -o PeakSegFPOP PeakSegFPOPLog.cpp funPieceListLog.cpp -I$HOME/include -L$HOME/lib -ldb_stl -Wl,-rpath=$HOME/lib
#+END_SRC

** Usage

*** The PeakSegFPOP command line program

The PeakSegFPOP program finds the peak positions and corresponding
piecewise constant segment means which optimize the Poisson
likelihood.

#+BEGIN_SRC shell-script
PeakSegFPOP coverage.bedGraph penalty [tmp.db]
#+END_SRC

The first argument =coverage.bedGraph= is a plain text file with 4
tab-separated columns: chrom, chromStart, chromEnd, coverage (chrom is
character and the others are integers). It should include data for
only one chromosome, and no gap regions.

The second argument =penalty= is a non-negative penalty value, for
example 0, 0.1, 1e3, or Inf.

The third argument =tmp.db= is optional. It is the path for a
temporary file which takes O(N log N) disk space (N = number of lines
in coverage.bedGraph). In practice you can expect the size of the
temporary file and the computation time to be as in the table
below. Min and max values show the variation over several values of
the penalty parameter (larger penalties require more time and disk
space), on an Intel(R) Core(TM) i7 CPU 930 @ 2.80GHz.

|       N | min(MB) | max(MB) | min(time) | max(time) |
|---------+---------+---------+-----------+-----------|
|   10000 |      12 |      43 | 1 sec     | 2 sec     |
|  100000 |     189 |     627 | 12 sec    | 25 sec    |
| 1000000 |    3462 |    7148 | 3 min     | 5 min     |
| 7135956 |    5042 |   41695 | 18 min    | 56 min    |
| 7806082 |    5270 |   33425 | 35 min    | 167 min   |

For a single run with penalty parameter =X=, the PeakSegFPOP program
outputs two files. The =coverage.bedGraph_penalty=X_segments.bed= file
has one line for each segment, and the following tab-separated
columns: =chrom=, =chromStart=, =chromEnd=, =segment.type=,
=segment.mean=. The =coverage.bedGraph_penalty=X_loss.tsv= has just
one line and the following tab-separated columns:

- =penalty= input penalty parameter.
- =segments= number of segments in the optimal model.
- =peaks= number of peaks in the optimal model.
- =bases= number of bases in the bedGraph file.
- =mean.pen.cost= mean penalized Poisson loss.
- =total.cost= total un-penalized Poisson loss. The following equation
  should hold for all data sets and penalty parameters:
  (total.cost + penalty * peaks)/bases = mean.pen.cost
- =status= is the optimal model feasible for the PeakSeg problem with
  strict inequality constraints? If infeasible, then there is at least
  one pair of adjacent segment means which are equal (and there is no
  optimal solution to the problem with strict inequality constraints).
- =mean.intervals= mean count of intervals (Poisson loss function
  pieces) over all the 2*N cost function models computed by the
  algorithm.
- =max.intervals= maximum number of intervals.

*** Running PeakSegFPOP on a whole genome

The PeakSegFPOP command line program recovers the optimal solution for
only one segmentation problem and one penalty parameter, but we
provide several R scripts which make it easy to use on the entire
genome. First, create sample directories with =coverage.bedGraph= for
the whole genome ([[http://bedtools.readthedocs.io/en/latest/content/tools/genomecov.html][bedtools genomecov -bga]]), and =labels.bed= for
genomic regions with and without peaks (a quick and easy way to create
labels is by visual inspection as in the [[http://cbio.mines-paristech.fr/~thocking/chip-seq-chunk-db/][McGill ChIP-seq peak
detection benchmark]]). For example, to run it on the =bcell= and
=tcell= samples of the [[https://github.com/tdhock/PeakSegJoint/tree/master/inst/exampleData][PeakSegJoint example data set]], convert them to

#+BEGIN_SRC 
H3K4me3_project/samples/bcell/McGill0091/coverage.bedGraph
H3K4me3_project/samples/bcell/McGill0091/labels.bed
H3K4me3_project/samples/bcell/McGill0322/coverage.bedGraph
H3K4me3_project/samples/bcell/McGill0322/labels.bed
H3K4me3_project/samples/tcell/McGill0107/coverage.bedGraph
H3K4me3_project/samples/tcell/McGill0107/labels.bed
H3K4me3_project/samples/tcell/McGill0322/coverage.bedGraph
H3K4me3_project/samples/tcell/McGill0322/labels.bed
#+END_SRC

In the example above we have the =H3K4me3_project= directory which
will contain all data sets, labels, and peak calls for a particular
project (in this example, all H3K4me3 samples). The =samples=
directory should contain a sub-directory for each sample group
(experimental conditions or cell types, e.g. =bcell= or =tcell=). Each
sample group directory should contain a sub-directory for each sample
(e.g. =McGill0091= or =McGill0322=). Then use the
[[file:create_problems_sample.R]] script on each sample

#+BEGIN_SRC shell-script
Rscript create_problems_sample.R hg19_problems.bed H3K4me3_project/samples/bcell/McGill0091
#+END_SRC

If you don't use hg19, then you can create another problems.bed file
([[file:gap2problems.R]]). The =create_problems_sample.R= script creates a
problem sub-directory for each line of =hg19_problems.bed=, for
example
=H3K4me3_project/samples/bcell/McGill0091/problems/chr4:75452279-191044276=
which is the largest region without gaps in hg19. Each problem
sub-directory contains
- =problem.bed= with one line for the coordinates of this part of the
  genome, and a =peaks.bed.sh= script.
- If there are labels in this part of the genome, =labels.bed= and a
  =target.tsv.sh= script.
- =target.tsv.sh= and =peaks.bed.sh= are shell scripts which can be
  launched via =bash= or =qsub= (edit the [[file:create_problems_sample.R]]
  script to reflect your cluster configuration).

The =target.tsv.sh= files contain one line

#+BEGIN_SRC shell-script
Rscript compute_coverage_target.R /path/to/H3K4me3_project/samples/bcell/McGill0091/problems/chr4:75452279-191044276
#+END_SRC

The [[file:compute_coverage_target.R]] script first creates
=coverage.bedGraph= for this problem ([[http://bedtools.readthedocs.io/en/latest/content/tools/intersect.html][intersectBed]] is required). If
there is a =labels.bed= file for this problem, it is used to compute
the target interval and save it to =target.tsv=. The target is the
largest interval of log(penalty) values for which PeakSegFPOP returns
peak models that have the minimum number of incorrect
=labels.bed=. The =target.tsv= files are used as input for training a
machine learning model that can predict optimal penalty values, even
for un-labeled parts of the genome. To train a model, use

#+BEGIN_SRC shell-script
Rscript train_model.R H3K4me3_project/samples H3K4me3_project/model.RData
#+END_SRC

which trains a model using
=H3K4me3_project/samples/*/*/problems/*/target.tsv= files, and saves
it to =H3K4me3_project/model.RData=. To make predictions, use =bash=
or =qsub= on the =H3K4me3_project/samples/*/*/problems/*/peaks.bed.sh=
scripts, which will create a =peaks.bed= file in each problem
sub-directory. These =peaks.bed= files can be collated to obtain peak
calls for the whole genome. For example, =cat H3K4me3_project/samples/bcell/McGill0091/problems/*/peaks.bed > H3K4me3_project/samples/bcell/McGill0091/peaks.bed= 
will create a file with all peak predictions for the =bcell/McGill0091= sample.

The next step is *joint* peak calling, which can be used to determine
genomic regions with similar or different peak patterns in the
different samples. To do that, run

#+BEGIN_SRC shell-script
Rscript create_problems_joint.R H3K4me3_project/samples chr4:75452279-191044276
#+END_SRC

which will create some =H3K4me3_project/jointProblems/chr4:*=
directories with =target.tsv.sh= and =peaks.bed.sh= scripts. One
directory and joint segmentation problem will be created for each
genomic region which has at least one sample with a predicted peak. To
train a joint peak calling model, first run =target.tsv.sh= scripts to
create =target.tsv= files, which contain an interval of log(penalty)
values that result in the minimal number of incorrectly predicted
labels for each joint segmentation problem. Then run

#+BEGIN_SRC shell-script
Rscript train_model_joint.R H3K4me3_project/jointProblems H3K4me3_project/joint.model.RData
#+END_SRC

which will train a joint peak calling model using the
=H3K4me3_project/jointProblems/*/target.tsv= files, saving the model
to =H3K4me3_project/joint.model.RData=. Finally, to make joint peak
predictions, run the =H3K4me3_project/jointProblems/*/peaks.bed.sh=
scripts, which will create corresponding =peaks.bed= files. These
files will contain one line for each sample that has a peak in this
region of the genome. For a given joint segmentation problem, each
sample will have the same peak start and end positions, which makes it
trivial to compute differences between samples.

** Related work

An in-memory implementation of PeakSegFPOP is available in the [[https://github.com/tdhock/coseg][coseg]] R
package. 

| implementation | time       | memory     | disk       |
|----------------+------------+------------+------------|
| command line   | O(N log N) | O(log N)   | O(N log N) |
| R pkg coseg    | O(N log N) | O(N log N) | 0          |

Note that although both implementations are O(N log N) time complexity
for N data points, the command line program is slower due to disk
read/write overhead.
